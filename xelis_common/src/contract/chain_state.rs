use std::{borrow::Cow, collections::HashMap};

use indexmap::{IndexMap, IndexSet};
use crate::{
    block::{Block, TopoHeight},
    contract::vm::ContractCaller,
    crypto::{Hash, PublicKey},
    versioned_type::VersionedState
};
use super::*;


// Changes made during the execution that can be persisted
// if the execution is successful
#[derive(Debug, Clone, Default)]
pub struct ChainStateChanges {
    // The contract cache
    // If the contract was called already, we may have a cache with data
    pub caches: HashMap<Hash, ContractCache>,
    // Assets cache
    // This either contains loaded assets, or registered
    // If its none, it means we didn't found the asset in storage
    pub assets: HashMap<Hash, Option<AssetChanges>>,
    // The contract event tracker
    // This is used to track all the events generated by the contract
    pub tracker: ContractEventTracker,
    // Events to callback after the execution
    pub events: Vec<CallbackEvent>,
    // Listeners for events registered
    // (contract, event_id) -> (listener_contract -> (chunk_id, max_gas))
    pub events_listeners: HashMap<(Hash, u64), Vec<(Hash, EventCallbackRegistration)>>,
    // Extra Gas fee accumulated during the execution
    pub extra_gas_fee: u64,
}

// ChainState shared across each executions
// The ChainState must be cloned before being used.
// If the contract execution is a success, the updated version
// replace the one in the cache.
pub struct ChainState<'a> {
    // Are we in debug mode
    // used by the contract to print debug information
    pub debug_mode: bool,
    // Are we in mainnet
    pub mainnet: bool,
    // The contract hash that was invoked as entry point
    pub entry_contract: Cow<'a, Hash>,
    // The topoheight of the block
    pub topoheight: TopoHeight,
    // Block hash in which the contract is executed
    pub block_hash: &'a Hash,
    // The block in which the contract is executed
    pub block: &'a Block,
    // Tx hash in which the contract is executed
    // If None, this means the contract was not
    // invoked by a TX.
    pub caller: ContractCaller<'a>,
    // All others caches if initialized
    pub global_caches: &'a HashMap<Hash, ContractCache>,
    // All modules already loaded
    // This is persisted across the calls
    pub global_modules: &'a HashMap<Cow<'a, Hash>, Option<(VersionedState, Option<Cow<'a, ContractModule>>)>>,
    // Loaded modules during this execution
    pub loaded_modules: HashMap<Hash, Option<(VersionedState, Option<ContractModule>)>>,
    // gas being injected to the invoke gas limit by contracts
    // it is kept in insertion order to rollback funds to contract
    // in case they were not fully used
    pub injected_gas: IndexMap<Source, u64>,
    // The contract logs
    // This is similar to an event log
    pub logs: Vec<ContractLog>,
    // executions manager
    pub executions: ExecutionsManager<'a>,
    // Changes made during the execution
    pub changes: ChainStateChanges,
    // Permission for inter-contract calls
    pub permission: Cow<'a, InterContractPermission>,
    // The contract environments available
    pub environments: Cow<'a, ContractEnvironments>,
    // Gas fee allowance for the execution
    // This is reduced from the used gas fee at the end of the execution
    // to prevent double refunding/paying
    pub gas_fee_allowance: u64,
    // Internal flag to determine if we should clone refs in the cache or not
    pub cache_clone_refs: bool,
}

// Aggregate all events from all executed contracts to track in one structure
#[derive(Debug, Clone, Default)]
pub struct ContractEventTracker {
    // Each tx-contract pair has its own transfers
    pub contracts_transfers: HashMap<(Hash, Hash), HashMap<PublicKey, HashMap<Hash, u64>>>,
    // All the transfers made by all contracts aggregated per public key
    pub aggregated_transfers: HashMap<PublicKey, HashMap<Hash, u64>>,
    // All assets registered by all contracts
    pub assets_created: IndexSet<Hash>
}
